# Функция суммы чисел:

# def sum_numbers(n):
#     summa = 0
#     for i in range(1, n+1): # n+1 пишем для того, чтобы последнее число входило в интервал
#         summa += i
#     print(summa)
# sum_numbers(5)

# Функция принимающая неограниченное количество элементов:

def sum_str(*args): # Если в аргументе поставить вначале * - это значит, негораниченное количество аргументов
    res = []
    count=0
    for i in args:
        res.insert(count, i)
        count +=1
    return res

print(sum_str('q', '4', 't'))
print(sum_str('q', '4', 't','q', '4', 't'))
print(sum_str(1,2,3))

# Рекурсия фибоначи

def fibonaci(n):
    if n in [1, 2]: # Если переменная n находится в списке [1, 2], то возвращаем 1 - это базис, выход из рекурсии
        return 1
    return fibonaci(n-1) + fibonaci(n-2)

list_1 = []
for i in range(1, 10):
    list_1.append(fibonaci(i)) # Заполняем список через рекурсию, которую написали выше
print(list_1)

# Быстрая сортировка при помощи рекурсии

def quick_sort(array):
    if len(array) <= 1: # Базис рекурсии
        return array
    else:
        pivot = array[0] # Создаем переменную, в которую кладем первый элемент массива
    less = [i for i in array[1:] if i <= pivot] # Создаем массив с отрицательными значениями относительно pivot и кладем только те i которые меньше или ровны pivot = array[0]
    greater = [i for i in array[1:] if i > pivot] # Создаем массив с положительными значениями относительно pivot и кладем только те i которые больше pivot 
    return quick_sort(less) + [pivot] + quick_sort(greater) # Складываем отрицательный массив(тут же его сортируем при помощи рекурсии) + Прибавляем pivot(число) так как это центр, но сначала привратим его в список, обрамив в [] + Прибавляем положительный массив(Тоже тут же сортируем его рекурсией)
print(quick_sort([14,1,0,5,9,6,3,58,7,5,2,7,-1,-6,-9,-4]))

# Сортировка слиянием через рекурсию

def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums) // 2 # Создаем переменную в которой будет хранится значение от длинну делим на 2
        left = nums[:mid] # Первый список, будем брать только левую часть списка
        right = nums[mid:] # Второй список, будем брать только правую часть списка
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0 # Создаем три переменных, i для left, j для right, затем складываем их и получаем ответ в k 
        while i < len(left) and j < len(right): # Запускаем условие: пока i меньше длинны левого списка и j меньше длинны правого списка(складываем обратно в пары)
            if left[i] < right[j]: 
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            k += 1 # Иначе не будет перехода в конечном списке nums[k]
        # Но может случится так, что в левой части числа закончились, а в правой нет и наоборот. Для этого прописываем условие для каждой стороны отдельно и добавляем остатки в конец
        while i < len(left):
            nums[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            nums[k] = right[j]
            j += 1
            k += 1

list_1 = [1,5,6,8,4,8,9,65,9,22,4]
merge_sort(list_1)
print(list_1)